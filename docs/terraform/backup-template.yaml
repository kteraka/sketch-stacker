{
    "TemplateBody": "AWSTemplateFormatVersion: '2010-09-09'\nDescription: Gyazo-like service using AWS services with Basic Authentication and CloudFront\n\n# ???????????UpdateImagesJsonLambda ???????? S3?????CloudFront????????????\n\nParameters:\n  ImageBucketName:\n    Type: String\n    Description: Name of the S3 bucket to store images\n  BasicAuthUsername:\n    Type: String\n    Description: Username for Basic Authentication\n  # BasicAuthPassword:\n  #   Type: String\n  #   Description: Password for Basic Authentication\n  #   NoEcho: true\n  ImagesJsonFilenamePath:\n    Type: String\n    Default: viewer/images.json\n    Description: This Json file logs filenames stored in ImageBucket\n  CloudFrontDistributionId:\n    Type: String\n    Description: For avoiding circular dependency in UpdateImagesJsonLambda. At\n      first deploy, fill here some dummy string. After deploy, fill here the\n      created Distribution ID in your stack and update stack so that\n      UpdateImagesJsonLambda will work.\n\nResources:\n  BasicAuthPassword:\n    Type: AWS::SecretsManager::Secret\n    Properties:\n      Name: !Sub ${AWS::StackName}Secret\n      Description: Password for Basic Authentication\n      GenerateSecretString:\n        SecretStringTemplate: '{\"secret_key\": \"password\"}'\n        GenerateStringKey: secret_key\n        PasswordLength: 16\n        ExcludePunctuation: true\n        RequireEachIncludedType: true\n  ImageBucket:\n    Type: AWS::S3::Bucket\n    DeletionPolicy: Retain\n    Properties:\n      BucketName: !Ref ImageBucketName\n      PublicAccessBlockConfiguration:\n        BlockPublicAcls: true\n        BlockPublicPolicy: true\n        IgnorePublicAcls: true\n        RestrictPublicBuckets: true\n      NotificationConfiguration:\n        LambdaConfigurations:\n          - Event: s3:ObjectCreated:*\n            Function: !GetAtt UpdateImagesJsonLambda.Arn\n    DependsOn:\n      - UpdateImagesJsonLambdaPermission\n  ImageBucketPolicy:\n    Type: AWS::S3::BucketPolicy\n    Properties:\n      Bucket: !Ref ImageBucket\n      PolicyDocument:\n        Statement:\n          - Action: s3:GetObject\n            Effect: Allow\n            Resource: !Sub ${ImageBucket.Arn}/*\n            Principal: '*'\n            Condition:\n              StringEquals:\n                aws:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}\n\n  ImageBucketOAC:\n    Type: AWS::CloudFront::OriginAccessControl\n    Properties:\n      OriginAccessControlConfig:\n        Name: !Sub OAC for ${ImageBucketName}\n        OriginAccessControlOriginType: s3\n        SigningBehavior: always\n        SigningProtocol: sigv4\n\n  # CORS Response Headers Policy\n  CORSResponseHeadersPolicy:\n    Type: AWS::CloudFront::ResponseHeadersPolicy\n    Properties:\n      ResponseHeadersPolicyConfig:\n        Name: !Sub ${AWS::StackName}-CORS-Policy\n        Comment: CORS headers for image viewer application\n        CorsConfig:\n          AccessControlAllowCredentials: false\n          AccessControlAllowHeaders:\n            Items:\n              - '*'\n          AccessControlAllowMethods:\n            Items:\n              - GET\n              - HEAD\n              - OPTIONS\n          AccessControlAllowOrigins:\n            Items:\n              - http://localhost:*\n              - https://localhost:*\n              - http://127.0.0.1:*\n              - https://127.0.0.1:*\n              - \"https://kteraka.github.io\"\n          AccessControlMaxAgeSec: 600\n          OriginOverride: true\n\n  CloudFrontDistribution:\n    Type: AWS::CloudFront::Distribution\n    Properties:\n      DistributionConfig:\n        DefaultCacheBehavior:\n          AllowedMethods:\n            - GET\n            - HEAD\n            - OPTIONS\n          ForwardedValues:\n            QueryString: false\n          TargetOriginId: ImageS3Origin\n          ViewerProtocolPolicy: redirect-to-https\n          ResponseHeadersPolicyId: !Ref CORSResponseHeadersPolicy\n        Enabled: true\n        HttpVersion: http2\n        Origins:\n          - DomainName: !GetAtt ImageBucket.RegionalDomainName\n            Id: ImageS3Origin\n            S3OriginConfig: {}\n            OriginAccessControlId: !Ref ImageBucketOAC\n        PriceClass: PriceClass_100\n\n  UploadLambdaExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: '2012-10-17'\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n      Policies:\n        - PolicyName: S3AccessPolicy\n          PolicyDocument:\n            Version: '2012-10-17'\n            Statement:\n              - Effect: Allow\n                Action:\n                  - s3:PutObject\n                Resource: !Sub arn:aws:s3:::${ImageBucketName}/* # Avoid recursive reference\n\n  UploadFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      Handler: index.handler\n      Role: !GetAtt UploadLambdaExecutionRole.Arn\n      Code:\n        ZipFile: |\n          const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');\n          const s3Client = new S3Client({ region: process.env.AWS_DEFAULT_REGION });\n\n          exports.handler = async (event) => {\n            try {\n              const body = JSON.parse(event.body);\n              const imageData = Buffer.from(body.image, 'base64');\n              const key = `${Date.now()}.png`;\n\n              const command = new PutObjectCommand({\n                Bucket: process.env.BUCKET_NAME,\n                Key: key,\n                Body: imageData,\n                ContentType: 'image/png',\n                StorageClass: 'GLACIER_IR'  // ?????????Glacier Instant Retrieval???\n              });\n\n              await s3Client.send(command);\n\n              return {\n                statusCode: 200,\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                  url: `https://${process.env.CLOUDFRONT_DOMAIN}/${key}`\n                })\n              };\n            } catch (error) {\n              console.error('Error:', error);\n              return {\n                statusCode: 500,\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ error: 'An error occurred while processing your request.' })\n              };\n            }\n          };\n      Runtime: nodejs22.x\n      Timeout: 10\n      Environment:\n        Variables:\n          BUCKET_NAME: !Ref ImageBucket\n          CLOUDFRONT_DOMAIN: !GetAtt CloudFrontDistribution.DomainName\n\n  ApiGateway:\n    Type: AWS::ApiGateway::RestApi\n    Properties:\n      Name: !Sub ${AWS::StackName}ImageUploadAPI\n\n  ApiResource:\n    Type: AWS::ApiGateway::Resource\n    Properties:\n      ParentId: !GetAtt ApiGateway.RootResourceId\n      PathPart: upload\n      RestApiId: !Ref ApiGateway\n\n  ApiAuthorizer:\n    Type: AWS::ApiGateway::Authorizer\n    Properties:\n      Name: !Sub ${AWS::StackName}BasicAuthorizer\n      Type: REQUEST\n      IdentitySource: method.request.header.Authorization\n      RestApiId: !Ref ApiGateway\n      AuthorizerUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AuthorizerFunction.Arn}/invocations\n      AuthorizerResultTtlInSeconds: 300\n\n  ApiMethod:\n    Type: AWS::ApiGateway::Method\n    Properties:\n      HttpMethod: POST\n      ResourceId: !Ref ApiResource\n      RestApiId: !Ref ApiGateway\n      AuthorizationType: CUSTOM\n      AuthorizerId: !Ref ApiAuthorizer\n      Integration:\n        Type: AWS_PROXY\n        IntegrationHttpMethod: POST\n        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UploadFunction.Arn}/invocations\n\n  ApiDeployment:\n    Type: AWS::ApiGateway::Deployment\n    DependsOn: ApiMethod\n    Properties:\n      RestApiId: !Ref ApiGateway\n      StageName: prod\n\n  LambdaApiGatewayPermission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      Action: lambda:InvokeFunction\n      FunctionName: !GetAtt UploadFunction.Arn\n      Principal: apigateway.amazonaws.com\n      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/POST/upload\n\n  AuthorizerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      Handler: index.handler\n      Role: !GetAtt UploadLambdaExecutionRole.Arn\n      Code:\n        ZipFile: |\n          exports.handler = async (event) => {\n            const authHeader = event.headers.Authorization || event.headers.authorization;\n            if (!authHeader) return generatePolicy('user', 'Deny', event.methodArn);\n\n            const encodedCreds = authHeader.split(' ')[1];\n            const plainCreds = Buffer.from(encodedCreds, 'base64').toString().split(':');\n            const username = plainCreds[0];\n            const password = plainCreds[1];\n\n            if (username === process.env.AUTH_USERNAME && password === process.env.AUTH_PASSWORD) {\n              return generatePolicy('user', 'Allow', event.methodArn);\n            }\n\n            return generatePolicy('user', 'Deny', event.methodArn);\n          };\n\n          const generatePolicy = (principalId, effect, resource) => {\n            return {\n              principalId: principalId,\n              policyDocument: {\n                Version: '2012-10-17',\n                Statement: [{\n                  Action: 'execute-api:Invoke',\n                  Effect: effect,\n                  Resource: resource\n                }]\n              }\n            };\n          };\n      Runtime: nodejs22.x\n      Environment:\n        Variables:\n          AUTH_USERNAME: !Ref BasicAuthUsername\n          AUTH_PASSWORD: !Sub '{{resolve:secretsmanager:${BasicAuthPassword}:SecretString:secret_key}}'\n\n  AuthorizerPermission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      Action: lambda:InvokeFunction\n      FunctionName: !Ref AuthorizerFunction\n      Principal: apigateway.amazonaws.com\n\n  # -----------------------------------------------------------------------------------------------\n  # images.json ???????\n  # -----------------------------------------------------------------------------------------------\n\n  # UpdateImagesJsonLambda ?IAM???\n  UpdateImagesJsonLambdaExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: '2012-10-17'\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      Policies:\n        - PolicyName: !Sub ${AWS::StackName}S3AccessPolicy\n          PolicyDocument:\n            Version: '2012-10-17'\n            Statement:\n              - Effect: Allow\n                Action:\n                  - s3:ListBucket\n                  - s3:GetObject\n                  - s3:PutObject\n                Resource:\n                  - !Sub arn:aws:s3:::${ImageBucketName}\n                  - !Sub arn:aws:s3:::${ImageBucketName}/*\n              - Effect: Allow\n                Action:\n                  - logs:CreateLogGroup\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: arn:aws:logs:*:*:*\n              - Effect: Allow\n                Action:\n                  - cloudfront:CreateInvalidation\n                Resource: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistributionId} # Avoid recursive reference\n  UpdateImagesJsonLambda:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub ${AWS::StackName}UpdateImagesJsonFunction\n      Handler: index.handler\n      Role: !GetAtt UpdateImagesJsonLambdaExecutionRole.Arn\n      Code:\n        ZipFile: |\n          const { S3Client, ListObjectsV2Command, PutObjectCommand } = require('@aws-sdk/client-s3');\n          const { CloudFront } = require('@aws-sdk/client-cloudfront');\n\n          const s3Client = new S3Client({ region: process.env.AWS_DEFAULT_REGION });\n\n          exports.handler = async (event) => {\n            const imageBucket = process.env.IMAGE_BUCKET;\n            const fileName = process.env.IMAGES_JSON_FILENAME_PATH;\n\n            try {\n              // imageBucket??????????????\n              const listObjectsCommand = new ListObjectsV2Command({ Bucket: imageBucket });\n              const listObjectsResponse = await s3Client.send(listObjectsCommand);\n              const fileNames = listObjectsResponse.Contents.map(object => object.Key);\n              console.log(fileNames);\n\n              // images.json????????????????\n              const jsonData = JSON.stringify(fileNames, null, 2);\n              console.log(jsonData);\n\n              // imageBucket?images.json???\n              const putObjectCommand = new PutObjectCommand({\n                Bucket: imageBucket,\n                Key: fileName,\n                Body: jsonData,\n                ContentType: 'application/json',\n              });\n\n              await s3Client.send(putObjectCommand);\n              console.log(\"/\"+fileName)\n              //images.json??????????viewer??????\n              const client = new CloudFront();\n              await client.createInvalidation({\n                DistributionId: process.env.DISTRIBUTION_ID,\n                InvalidationBatch: {\n                  CallerReference: new Date().toISOString(),\n                  Paths: {\n                    Quantity: 1,\n                    Items: [\"/\" + fileName]\n                  }\n                }\n              });\n              return {\n                statusCode: 200,\n                body: 'images.json saved successfully!',\n              };\n            } catch (error) {\n              console.error('Error processing S3 event', error);\n              return {\n                statusCode: 500,\n                body: 'Error processing S3 event',\n              };\n            }\n          };\n      Environment:\n        Variables:\n          IMAGE_BUCKET: !Ref ImageBucketName\n          DISTRIBUTION_ID: !Ref CloudFrontDistributionId # Avoid recursive reference\n          IMAGES_JSON_FILENAME_PATH: !Ref ImagesJsonFilenamePath\n      Runtime: nodejs22.x # ????Node.js???\n      Timeout: 300 # ???????300??\n\n  # Lambda???ImageBucket???????????\n  UpdateImagesJsonLambdaPermission:\n    Type: AWS::Lambda::Permission\n    Properties:\n      Action: lambda:InvokeFunction\n      FunctionName: !Ref UpdateImagesJsonLambda\n      Principal: s3.amazonaws.com\n      SourceArn: !Sub arn:aws:s3:::${ImageBucketName} # Avoid recursive reference\n\n# -----------------------------------------------------------------------------------------------\n\nOutputs:\n  ApiEndpoint:\n    Description: API Endpoint\n    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod/upload\n  CloudFrontDomain:\n    Description: CloudFront Distribution Domain\n    Value: !GetAtt CloudFrontDistribution.DomainName",
    "StagesAvailable": [
        "Original",
        "Processed"
    ]
}
